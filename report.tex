\documentclass[listof=totoc]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={7in, 10in}]{geometry}
\usepackage{breqn}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{natbib}
\lstset{literate=%
	{æ}{{\ae}}1
	{å}{{\aa}}1
	{ø}{{\o}}1
	{Æ}{{\AE}}1
	{Å}{{\AA}}1
	{Ø}{{\O}}1
	{-}{{-}}1
}

\title{A General Line-Based Data Serialization Language}
\author{Kevin Robert Stravers}
\date{April 30th, 2016}

\begin{document}

\maketitle

\iffalse
	\tableofcontents
	\lstlistoflistings
\fi

\section{Introduction}
This article will explore various markup and configuration languages and their flaws. A solution to the flaws is presented near the end.
\section{Problems}

\subsection{TOML}
TOML (Tom's Obvious Minimal Language) is a relatively new language that tries to be a specification of the 'ini' file.
It tries to do this by heading a subsection with a name that specifies which table the following entries are part of.

\begin{verbatim}
[tablename]
key = "value"
otherkey = "value"
\end{verbatim}

Nested tables are fine in TOML:

\begin{verbatim}
[tablename.nestedtable]
key = "value"
otherkey = "value"
\end{verbatim}

TOML is a good choice for simple configuration, but there are a few scalability problems.

\begin{enumerate}
	\item Non-trivial parsing
	\item Inline tables are limited to one line
	\item Need to state the complete path for multiple tables
\end{enumerate}

The problem with stating the complete path is that we get issues like the following:

\begin{verbatim}
[tablename.nestedtable]
key = "value"
otherkey = "value"
[tablename.nestedtable.x]
key = "value"
otherkey = "value"
[tablename.nestedtable.y]
key = "value"
otherkey = "value"
\end{verbatim}

It is redundant to state 'tablename.nestedtable'. Inline tables, due to the one-line limitation become ugly.

\subsection{JSON}
JavaScript object notation is the object building notation used by the Javascript language.
\begin{enumerate}
	\item Non-trivial parsing
	\item Liberal use of quotation marks
	\item Hard to read
\end{enumerate}

\subsection{XML}
XML is an extendable and quite simple markup language. XML allows tags in table names.
\begin{enumerate}
	\item Non-trivial parsing
	\item Verbose tag symbols
	\item Hard to process by a text processor
	\item Overly complicated escaping
\end{enumerate}

\section{Solution}
1. To solve the above problems, we first need trivial parsing. This is done by making the language line-based and simple-delimiter separated.

\begin{verbatim}
tablename.nestedtable.key value
tablename.nestedtable.otherkey value
tablename.nestedtable.x.key value
tablename.nestedtable.x.otherkey value
tablename.nestedtable.y.key value
tablename.nestedtable.y.otherkey value
\end{verbatim}

2. We have only one line, so there's nothing we can do.
3. Stating the complete path is redundant. We implement a simple substitution.

\begin{verbatim}
tablename.nestedtable.key value
                      otherkey value
                      x.key value
                      x.otherkey value
                      y.key value
                      y.otherkey value
\end{verbatim}


Note the spaces. The algorithm for manipulating this can store the previous key. Whenever a leading space is
encountered, the original character can be used instead. This scales with any number of nestings.

New problem: If I change the table name, then I need to remove many spaces. Can this be solved?\\
$\Rightarrow$ Solution: a tool can be used for this. It parses it into a tree, you change a name, and it outputs it. Note that the actual text is still easy to process.\\
New problem: how are values differentiated from keys if spaces are used?\\
$\Rightarrow$ Solution: use '=' or ':'.\\
New problem: the spaces can be quite long and take up a lot of space.\\
$\Rightarrow$ Solution denote the beginning of a table and its end.\\

\begin{verbatim}
begin tablename.nestedtable.key
	otherkey value
	x.key value
	x.otherkey value
	y.key value
	y.otherkey value
end
\end{verbatim}

Every 'begin' can be put into a list. List can be put into a table.
This is trivial to parse using awk.

Problem: Spaces are field separators, what if we don't want to separate a field?\\
$\Rightarrow$ Solution: use \textbackslash s.
Problem: What if we want a new line in our output.
$\Rightarrow$ Solution: use \textbackslash n.
Problem: What if we want a new line in our output.
$\Rightarrow$ Solution: use \textbackslash n.
Problem: begin/end don't have matching tags in edits.
$\Rightarrow$ Solution: use [ and ] or { and }.

\begin{verbatim}
{ glossary
  title example glossary
  { GlossDiv
    title S
    { GlossList
      { GlossEntry
        ID SGML
        SortAs SGML
        GlossTerm Standard Generalized Markup Language
        Acronym SGML
        Abbrev ISO 8879:1986
        { GlossDef
          para A meta-markup language, used to create markup languages such as DocBook.
          [ GlossSeeAlso
            GML
            XML
          ]
          GlossSee markup
        }
      }
    }
  }
}
\end{verbatim}

Problem: Using \lbrack \rbrack or \{\} in text causes the editor to not display correctly.\\
$\Rightarrow$ Solution: Use escape codes.

What escape codes should be used then?

Problem: We can't write multiline strings.
$\Rightarrow$ Solution: Use an array.

\section{Grammar}
The full grammar for the language is described here. All literals are in the form of PERL regexes.

\begin{verbatim}
START ::= { NMEM }*;

NARRAY ::= '[' name '\n' { UMEM }* ']';
NENTRY ::= '{' name '\n' { NMEM }* '}';

ARRAY ::= '[' '\n' { UMEM }* ']';
ENTRY ::= '{' '\n' { NMEM }* '}';

name ::= '[^\n]+';
DATA ::= '[^\n]*\n';
NMEM ::= name DATA | NARRAY | NENTRY;
UMEM ::= DATA | ARRAY | ENTRY;
\end{verbatim}

\section{Realization}
Tools are needed to make any data serialization language realizable.

\begin{enumerate}
	\item json2acon - A JSON to ACON converter. (Written in Rust, using Serde)
	\item acon - An ACON expander. (Written in awk)
\end{enumerate}

Tools that have to be implemented:
\begin{enumerate}
	\item xml2acon - An XML to ACON converter.
	\item acon2xml - An ACON to XML converter.
	\item acon2json - An ACON to JSON converter.
	\item acon - An ACON expander. (Written in awk)
\end{enumerate}


\lstlistoflistings

\lstinputlisting[caption={json2acon, converts JSON to ACON},breaklines=true,frame=single,language=c++]{src/main.rs}
\lstinputlisting[caption={acon, converting ACON to line-based ACON},breaklines=true,frame=single,language=awk]{acon}


\end{document}
