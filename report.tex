\documentclass[listof=totoc]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={7in, 10in}]{geometry}
\usepackage{breqn}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{natbib}
\lstset{literate=%
	{æ}{{\ae}}1
	{å}{{\aa}}1
	{ø}{{\o}}1
	{Æ}{{\AE}}1
	{Å}{{\AA}}1
	{Ø}{{\O}}1
	{-}{{-}}1
}

\title{Koml}
\author{Kevin Robert Stravers}
\date{April 29th, 2016}

\begin{document}

\maketitle

\iffalse
	\tableofcontents
	\lstlistoflistings
\fi

\chapter{Problems}
\section{Introduction}
This article will explore various markup and configuration languages and their flaws. A solution to the flaws is presented near the end.

\section{TOML}
TOML (Tom's Obvious Minimal Language) is a relatively new language that tries to be a specification of the 'ini' file.
It tries to do this by heading a section with a name that specifies which table the following entries are part of.

\begin{verbatim}
[tablename]
key = "value"
otherkey = "value"
\end{verbatim}

Nested tables are fine in TOML:

\begin{verbatim}
[tablename.nestedtable]
key = "value"
otherkey = "value"
\end{verbatim}

TOML is a good choice for simple configuration, but there are a few scalability problems.

\begin{itemize}
	\item Non-trivial parsing
	\item Inline tables are limited to one line
	\item Need to state the complete path for multiple tables
\end{itemize}

The problem with stating the complete path is that we get issues like the following:

\begin{verbatim}
[tablename.nestedtable]
key = "value"
otherkey = "value"
[tablename.nestedtable.x]
key = "value"
otherkey = "value"
[tablename.nestedtable.y]
key = "value"
otherkey = "value"
\end{verbatim}

It is redundant to state 'tablename.nestedtable'. Inline tables, due to the one-line limitation become ugly.

\section{Solution}
1. To solve the above problems, we first need trivial parsing. This is done by making the language line-based and simple-delimiter separated.

\begin{verbatim}
tablename.nestedtable.key value
tablename.nestedtable.otherkey value
tablename.nestedtable.x.key value
tablename.nestedtable.x.otherkey value
tablename.nestedtable.y.key value
tablename.nestedtable.y.otherkey value
\end{verbatim}

2. We have only one line, so there's nothing we can do.
3. Stating the complete path is redundant. We implement a simple substitution.

\begin{verbatim}
tablename.nestedtable.key value
                      otherkey value
                      x.key value
                      x.otherkey value
                      y.key value
                      y.otherkey value
\end{verbatim}


Note the spaces. The algorithm for manipulating this can store the previous key. Whenever a leading space is
encountered, the original character can be used instead. This scales with any number of nestings.

New problem: If I change the table name, then I need to remove many spaces. Can this be solved?
Solution: a tool can be used for this. It parses it into a tree, you change a name, and it outputs it. Note that the actual text is still easy to process.
New problem: how are values differentiated from keys if spaces are used?
Solution: use '=' or ':'.
New problem: the spaces can be quite long and take up a lot of space.
Solution denote the beginning of a table and its end.

\begin{verbatim}
begin tablename.nestedtable.key
	otherkey value
	x.key value
	x.otherkey value
	y.key value
	y.otherkey value
end
\end{verbatim}

Every 'begin' can be put into a list.

\end{document}
