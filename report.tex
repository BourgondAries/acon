\documentclass[listof=totoc]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={7in, 10in}]{geometry}
\usepackage{breqn}
\usepackage{caption}
\usepackage{varwidth}
\usepackage{verbatimbox}
\usepackage{float}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{natbib}
\lstset{literate=%
	{æ}{{\ae}}1
	{å}{{\aa}}1
	{ø}{{\o}}1
	{Æ}{{\AE}}1
	{Å}{{\AA}}1
	{Ø}{{\O}}1
	{-}{{-}}1
}

\title{A General Line-Based Data Serialization Language}
\author{Kevin Robert Stravers}
\date{April 30th, 2016}

\begin{document}

\maketitle

\iffalse
  \tableofcontents
  \lstlistoflistings
\fi

\section{Introduction}
\noindent This article will explore various markup and configuration languages and their flaws. A solution to the flaws is presented near the end.

\section{Problems}
\subsection{TOML}
\noindent TOML (Tom's Obvious Minimal Language) is a relatively new language that tries to be a specification of the 'ini' file.
It tries to do this by heading a subsection with a name that specifies which table the following entries are part of.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
[group1]
key1 = "value1"
key2 = "value2"
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent Nested tables are fine in TOML:

\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
[group1.group2]
key1 = "value1"
key2 = "value2"
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent TOML is a good choice for simple configuration, but there are a few scalability problems.


\noindent The problem with stating the complete path is that we get issues like the following:


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
[group1.group1]
key1 = "value1"
key2 = "value2"
[group1.group2]
key1 = "value1"
key2 = "value2"
[group1.group3]
key1 = "value1"
key2 = "value2"
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent It is redundant to state 'group1'. This can be done using inline tables. This is ugly due to the one-line limitation.

\begin{enumerate}
  \item Non-trivial parsing
  \item Inline tables are limited to one line
  \item Need to state the complete path for multiple nested tables
  \item Large standard because dates are included (RFC3339)
  \item Not friendly for line-based tools
\end{enumerate}

\subsection{JSON}
\noindent JavaScript object notation is the object building notation used by the Javascript language.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
{ "group1": {
  "key1": "value1",
  "key2": "value2"
}}
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent JSON can be used to build arbitrary structures easily.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
{ "group1": {
  "group1": {
    "key1": "value1",
    "key2": "value2"
  },
  "group2": {
    "key1": "value1",
    "key2": "value2"
  },
  "group3": {
    "key1": "value1",
    "key2": "value2"
  }
}}
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\begin{enumerate}
  \item Non-trivial parsing
  \item Liberal use of quotation marks
  \item Hard to read
  \item Required commas to separate items
  \item Not friendly for line-based tools
\end{enumerate}

\subsection{XML}
\noindent XML is an extendable and quite simple markup language. XML allows tags in table names.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
<group1>
  <key1>value1</key1>
  <key2>value2</key2>
</group1>
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent The language also allows one to nest tables. Although it is unclear where tags are necessary.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
<group1>
  <group1>
    <key1>value1</key1>
    <key2>value2</key2>
  </group1>
  <group2>
    <key1>value1</key1>
    <key2>value2</key2>
  </group1>
  <group3>
    <key1>value1</key1>
    <key2>value2</key2>
  </group3>
</group1>
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent XML allows one to give data as either an element or attribute.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
<key attribute="value">
  <element></element>
</key>
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent There are numerous problems with this format.

\begin{enumerate}
  \item Unclear convention for using elements or attributes
  \item No native arrays
  \item Non-trivial parsing
  \item Verbose tag symbols
  \item Closing symbols contain redundant data
  \item Little room for variables that need to be without spaces
  \item Hard to process by a text processor
  \item Overly complicated escaping
  \item Not friendly for line-based tools
\end{enumerate}

\section{Solution}
\noindent Problem: None of the above solutions are remotely trivial to parse. \\
$\Rightarrow$ To solve the above problems, we first need trivial parsing. This is done by making the language line-based and simple-delimiter separated.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
key1 value1
key2 value2
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent Problem: We need a way to group items together. \\
$\Rightarrow$ use dots as separators.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
group1.key1 value1
group1.key2 value2

group2.key1 value1
group2.key2 value2
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent Problem: We want to be able to group items together with a common prefix without stating the names all the time. \\
$\Rightarrow$ use tables.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
table group1
  key1 value1
  key2 value2
end
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent This is trivial to parse using awk.

\noindent Problem: What escaping convention should be used? \\
$\Rightarrow$ Solution: use base64 codes within parentheses. \\
Problem: Spaces are field separators, what if we don't want to separate a field? \\
$\Rightarrow$ Solution: use (g). \\
Problem: What if we want a new line in our output. \\
$\Rightarrow$ Solution: use (K). \\
Problem: table/end don't have matching tags in edits. \\
$\Rightarrow$ Solution: use \lbrack and \rbrack or \{ and \}. Editors match these nicely.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
{ group1
  key1 value1
  key2 value2
}
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent Problem: Using (), \lbrack \rbrack, or \{\} in text causes the editor to not display correctly. \\
$\Rightarrow$ Solution: Use escape codes: (o), (p), (Bb), (Bd), (B7), (B9). \\
\noindent Problem: We can't write multiline strings. \\
$\Rightarrow$ Solution: Use an array. \\
\noindent Problem: It's unclear when whitespace is included in the value.
$\Rightarrow$ Solution: every field gets space-separated. If you want to insert
whitespace on its on, you can use (g) for spaces, (K) for newlines.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
{ group1
  key1 (g)Here we force a space in the beginning
  key2 value2
}
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\textit{Pro:} This format allows easily formatted, conventional text:

\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
{ mail
  [ message
    This is my message to you.
    The message can contain many lines.
    As you may know, each line is its own variable.
    However, the program decides how to process
    each line! This makes it possible to write simple,
    space-separated text easily.

    Teksten kan være i flere språk. Det er lovlig.
  ]
}
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\noindent The above will not include the tabs or spaces that are used to indent the format. This makes it ideal for raw string messages. New lines are will be new lines inside arrays. This is useful when formatting. The system is text-based and has no verification of data.
The program at hand will need to verify its own data.


\subsection{Meaning of Named Tables and Arrays inside Arrays}
\noindent The meaning of names tables and named arrays inside arrays is to prevent verbosity. \\
\noindent First let's explore what named tables and arrays are:

\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
{ table-name
}
[ array-name
]
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

An unnamed table and array:

\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
{
}
[
]
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

The meaning of named arrays and tables inside arrays (as, normally, elements in an array are not named.) is to automatically put the element in an unnamed table:

\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
[ array-name
  { table-name
    key value
  }
  [ other-array-name
    other value
  ]
]
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

Is the same as

\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
[ array-name
  {
    { table-name
      key value
    }
  }
  {
    [ other-array-name
      other value
    ]
  }
]
\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\section{Grammar}
\noindent The full grammar for the language is described here. All literals are in the form of PERL regexes.


\begin{figure}[H]
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
START ::= { NMEM }*;

NARRAY ::= ws '[' ws name '\n' { UMEM }* ']';
NENTRY ::= ws '{' ws name '\n' { NMEM }* '}';

ARRAY ::= ws '[' '\n' { UMEM }* ']';
ENTRY ::= ws '{' '\n' { NMEM }* '}';

ws ::= '[\t ]*';
name ::= '[^\n]+';
DATA ::= '[^\n]*\n';
NMEM ::= ws name DATA | NARRAY | NENTRY;
UMEM ::= ws DATA | ARRAY | ENTRY;

\end{verbatim}
\end{varwidth}
\caption{}
\end{figure}

\section{Realization}
\noindent Tools are needed to make any data serialization language realizable.

\begin{enumerate}
  \item json2acon - A JSON to ACON converter. (Written in Rust, using Serde)
  \item acon - An ACON expander. (Written in awk)
\end{enumerate}

\noindent Tools that have to be implemented:
\begin{enumerate}
  \item xml2acon - An XML to ACON converter.
  \item acon2xml - An ACON to XML converter.
  \item acon2json - An ACON to JSON converter.
  \item acon - An ACON expander. (Written in awk)
\end{enumerate}


\lstlistoflistings

\lstinputlisting[caption={json2acon, converts JSON to ACON},breaklines=true,frame=single,language=c++]{src/main.rs}
\lstinputlisting[caption={acon, converting ACON to line-based ACON},breaklines=true,frame=single,language=awk]{acon}


\end{document}
