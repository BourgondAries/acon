\documentclass[listof=totoc]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={7in, 10in}]{geometry}
\usepackage{breqn}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{natbib}
\lstset{literate=%
	{æ}{{\ae}}1
	{å}{{\aa}}1
	{ø}{{\o}}1
	{Æ}{{\AE}}1
	{Å}{{\AA}}1
	{Ø}{{\O}}1
	{-}{{-}}1
}

\title{Koml}
\author{Kevin Robert Stravers}
\date{April 29th, 2016}

\begin{document}

\maketitle

\iffalse
	\tableofcontents
	\lstlistoflistings
\fi

\chapter{Problems}
\section{Introduction}
This article will explore various markup and configuration languages and their flaws. A solution to the flaws is presented near the end.

\section{TOML}
TOML (Tom's Obvious Minimal Language) is a relatively new language that tries to be a specification of the 'ini' file.
It tries to do this by heading a section with a name that specifies which table the following entries are part of.

\begin{verbatim}
[tablename]
key = "value"
otherkey = "value"
\end{verbatim}

Nested tables are fine in TOML:

\begin{verbatim}
[tablename.nestedtable]
key = "value"
otherkey = "value"
\end{verbatim}

TOML is a good choice for simple configuration, but there are a few scalability problems.

\begin{enumerate}
	\item Non-trivial parsing
	\item Inline tables are limited to one line
	\item Need to state the complete path for multiple tables
\end{enumerate}

The problem with stating the complete path is that we get issues like the following:

\begin{verbatim}
[tablename.nestedtable]
key = "value"
otherkey = "value"
[tablename.nestedtable.x]
key = "value"
otherkey = "value"
[tablename.nestedtable.y]
key = "value"
otherkey = "value"
\end{verbatim}

It is redundant to state 'tablename.nestedtable'. Inline tables, due to the one-line limitation become ugly.

\section{JSON}
JavaScript object notation is the object building notation used by the Javascript language.
\begin{enumerate}
	\item Non-trivial parsing
	\item Liberal use of quotation marks
	\item Hard to read
\end{enumerate}

\section{XML}
XML is an extendable and quite simple markup language. XML allows tags in table names.
\begin{enumerate}
	\item Non-trivial parsing
	\item Verbose tag symbols
	\item Hard to process by a text processor
	\item Overly complicated escaping
\end{enumerate}

\section{Solution}
1. To solve the above problems, we first need trivial parsing. This is done by making the language line-based and simple-delimiter separated.

\begin{verbatim}
tablename.nestedtable.key value
tablename.nestedtable.otherkey value
tablename.nestedtable.x.key value
tablename.nestedtable.x.otherkey value
tablename.nestedtable.y.key value
tablename.nestedtable.y.otherkey value
\end{verbatim}

2. We have only one line, so there's nothing we can do.
3. Stating the complete path is redundant. We implement a simple substitution.

\begin{verbatim}
tablename.nestedtable.key value
                      otherkey value
                      x.key value
                      x.otherkey value
                      y.key value
                      y.otherkey value
\end{verbatim}


Note the spaces. The algorithm for manipulating this can store the previous key. Whenever a leading space is
encountered, the original character can be used instead. This scales with any number of nestings.

New problem: If I change the table name, then I need to remove many spaces. Can this be solved?\\
$\Rightarrow$ Solution: a tool can be used for this. It parses it into a tree, you change a name, and it outputs it. Note that the actual text is still easy to process.\\
New problem: how are values differentiated from keys if spaces are used?\\
$\Rightarrow$ Solution: use '=' or ':'.\\
New problem: the spaces can be quite long and take up a lot of space.\\
$\Rightarrow$ Solution denote the beginning of a table and its end.\\

\begin{verbatim}
begin tablename.nestedtable.key
	otherkey value
	x.key value
	x.otherkey value
	y.key value
	y.otherkey value
end
\end{verbatim}

Every 'begin' can be put into a list. List can be put into a table.
This is trivial to parse using awk.

Problem: Spaces are field separators, what if we don't want to separate a field?\\
$\Rightarrow$ Solution: use \textbackslash s.
Problem: What if we want a new line in our output.
$\Rightarrow$ Solution: use \textbackslash n.
Problem: What if we want a new line in our output.
$\Rightarrow$ Solution: use \textbackslash n.
Problem: begin/end don't have matching tags in edits.
$\Rightarrow$ Solution: use [ and ] or { and }.

\begin{verbatim}
{ glossary
  title example glossary
  { GlossDiv
    title S
    { GlossList
      { GlossEntry
        ID SGML
        SortAs SGML
        GlossTerm Standard Generalized Markup Language
        Acronym SGML
        Abbrev ISO 8879:1986
        { GlossDef
          para A meta-markup language, used to create markup languages such as DocBook.
          [ GlossSeeAlso
            GML
            XML
          ]
          GlossSee markup
        }
      }
    }
  }
}
\end{verbatim}

Problem: Using \lbrack \rbrack or \{\} in text causes the editor to not display correctly.\\
$\Rightarrow$ Solution: Use escape codes.

What escape codes should be used then?

Problem: We can't write multiline strings.
$\Rightarrow$ Solution: Use an array.

\section{Grammar}

\begin{verbatim}
{ name
	[ also-named
		# Unnamed array
		[
			1 2 3 4
			5 6 7 8
		]
		# Unnamed table
		{
			key value
		}
	]
}
\end{verbatim}

\section{Grammar}
The full grammar for the language is described here. All literals are in the form of PERL regexes.

\begin{verbatim}
START ::= { NMEM }*;

NARRAY ::= '[' name '\n' { UMEM }* ']';
NENTRY ::= '{' name '\n' { NMEM }* '}';

ARRAY ::= '[' '\n' { UMEM }* ']';
ENTRY ::= '{' '\n' { NMEM }* '}';

name ::= '[^\n]+';
DATA ::= '[^\n]*\n';
NMEM ::= name DATA | NARRAY | NENTRY;
UMEM ::= DATA | ARRAY | ENTRY;
\end{verbatim}

\end{document}
